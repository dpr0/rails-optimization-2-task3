exit
@buses[hash[:bus][:number].to_i]
c
@buses
hash[:bus][:number]
@buses[hash[:bus][:number].to_i]
c
hash[:bus][:services].map { |s| "(#{bus.id}, #{BusService::SERVICES.index(s)})" }
c
hash[:bus][:services].map { |s| "(#{bus.id}, #{BusService::SERVICES.index(s)})" }
c
hash[:bus][:services].map { |s| "(#{bus.id}, #{BusService::SERVICES.index(s)})" }
c
hash[:bus][:services].map { |s| "(#{bus.id}, #{BusService::SERVICES.index(s)})" }
hash[:bus][:services].present?
c
create_buses_services(hash[:bus][:services].map { |s| "(#{bus.id}, #{BusService::SERVICES.index(s)})" }) if hash[:bus][:services].present?
hash[:bus][:services].present?
hash[:bus][:services].map { |s| "(#{bus.id}, #{BusService::SERVICES.index(s)})" }
bus.id
bus
exit
bus
exit
c
city_to_id
city_from_id
c
Bus[:1]
Bus.find 157
Bus.find 156
@buses.map(&:id)
@buses
@buses.select { |x| x.id = 1 }
@buses
    @buses = Bus.where(id: bus_ids)
    bus_ids = @trips.map { |x| x['bus_id'] }
@trips.map { |x| x['bus_id'] }
@trips.map(&:bus_id)
c
@tr.first['bus_services'][1..-2].split(',')
@tr.first['bus_services'][1..-2]
@tr.first['bus_services']
c
@tr.first['id']
@tr.first[:id]
@tr.first
@tr.count
@tr
c
1
@tr.each { |x| puts x }
@tr.fields
@tr.methods
@tr.rows
c
@tr.fsize
@tr.size
@tr.all?
@tr.all
@tr
    @tr = Trip.connection.execute("select * from trips t left join bus_services bs on t.bus_id = bs.bus_id    where t.from_id = #{@from.id} and t.to_id = #{@to.id} order by t.start_time")
    @tr = Trip.connection.execute "select * from trips t left join bus_services bs on t.bus_id = bs.bus_id    where t.from_id = #{@from.id} and t.to_id = #{@to.id} order by t.start_time;"
    @tr = Trip.connection.execute <<-SQL select * from trips t left join bus_services bs on t.bus_id = bs.bus_id    where t.from_id = #{@from.id} and t.to_id = #{@to.id} order by t.start_time; SQL
    SQL
    where t.from_id = #{@from.id} and t.to_id = #{@to.id} order by t.start_time;
    select * from trips t left join bus_services bs on t.bus_id = bs.bus_id
@tr = Trip.connection.execute <<-SQL
@to.id
@from.id
@from
@tr = Trip.connection.execute <<-SQL @from
   11:     SQL
   10:     VALUES #{bus_services.join(',')};
    9:     INSERT INTO bus_services (bus_id, service_id)
@tr = Trip.connection.execute <<-SQL
@trips = Trip.includes(bus: :bus_services).where(from: @from, to: @to).order(:start_time)
c
Trip.all.size
Trip
c
@cities
    City.all.each { |c| @cities[c.name] = c.id }
City.all
@cities
c
 @cities
c
Bus.all.pluck(:number).sort
Bus.all.pluck(:number).uniq.size
Bus.all.pluck(:number).size
Bus.all.pluck :number
Bus.all.pluck : number
Bus.last
Bus.first
Bus.all.size
exit
c
hash[:bus][:services].map { |s| "(#{bus.id}, #{BusService::SERVICES.index(s)})" }
bus
c
bus = Bus.create!(number: hash[:bus][:number].to_i, model: Bus::MODELS.index(hash[:bus][:model]))
bus = Bus.create(number: hash[:bus][:number].to_i, model: Bus::MODELS.index(hash[:bus][:model]))
Bus::MODELS
hash[:bus][:model]
bus
hash[:bus][:services].map { |s| "(#{bus.id}, #{BusService::SERVICES.index(s)})" }
c
hash[:bus][:services].map { |s| "(#{bus_id}, #{BusService::SERVICES.index(s)})" }
c
n
c
City.cached
City[name]
City.all
name
@cities.include? name
City[name]
City[name].id
c
City[name].id
c
City[name].id
City[name]
name
exit
учше
Trip.import @trips
City.all
@cities
c
 Trip.import @trips, recursive: true
c
Bus.import @buses, recursive: true
@buses
c
  system 'bin/rake reload_json[fixtures/small.json]'
c
Bus.all
  system 'bin/rake reload_json[fixtures/small.json]'
  system! 'bin/rake reload_json[fixtures/small.json]'
Bus.all
City.all
Trip.all
c
Trip.all
Trip.last
Trip.first
@to = City[params[:to]]
 @from = City[params[:from]]
n
c
cached.key?(key)
cached
 key_s.to_sym
c
City[params[:from]]
c
City[params[:from]]
cached_by_id
c
City[params[:from]]
c
exception
n
val
c
v
c
z.select { |x| x.name == params[:from] }
z = City.all
City.all
City[params[:from]]
c
City.select([:id, :name]).order(:id).index_by(&:id).each {  |_, v| [:id, :name].each { |attr| v.public_send(attr).freeze } }
City.select([:id, :name]).order(:id).index_by(&:id).each {  |_, v| [:id, :name].each { |attr| v.public_send(attr).freeze }; v.freeze }
City.select([:id, :name]).order(:id).index_by(&:id).each {  |_, v| [:id, :name].each { |attr| v.public_send(attr).freeze }; v.freeze}.freeze
City.select([:id, :name]).order(:id).index_by(&:id)
City.select([:id, :name])
City[params[:from]]
params
c
raw_line.chomp.last
MultiJson.load(FROM + raw_line[0..(raw_line.chomp.last == "]" ? -3 : -10)], symbolize_keys: true)
c
@trips.last.bus.buses_services
@trips.last.bus.buses_service
@trips.last.bus.service
@trips.last.bus.services
@trips.last.bus
@trips.last
@trips
n
c
Bus::MODELS
Bus
Bus.MODELS
c
@cities.include? name
name
@cities[name]
c
city.id
@cities << name
city = City.create(name: name)city = City.create(name: name)
city = City.create(name: name)
@cities.index(name)
s
city_id(hash[:from])
hash
c
BusesService.delete_all
City.delete_all
Bus.delete_all
n
exit
BusService.delete_all
Trip.delete_all
City.delete_all
n
c
    x = MultiJson.load(FROM + raw_line[0..(raw_line.last == "\n" ? -3 : -10)], :symbolize_keys => true)
    x = MultiJson.load(FROM + raw_line[0..(raw_line.last == "\n" ? -2 : -10)], :symbolize_keys => true)
raw_line
    x = MultiJson.load(FROM + raw_line[0..(raw_line.last == "\n" ? -1 : -10)], :symbolize_keys => true)
x
raw_line.last == "\n"
c
raw_line.last == "\n"
raw_line.last
raw_line
c
raw_line
c
с
c
x
c
x
c
x
c
x
exit
c
x
c
x
c
exit
x
c
x
exit
MultiJson.load(str, :symbolize_keys => true)
str.to_h
